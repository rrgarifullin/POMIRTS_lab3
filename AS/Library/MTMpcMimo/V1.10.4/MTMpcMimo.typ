(********************************************************************
 * COPYRIGHT -- Bernecker + Rainer
 ********************************************************************
 * Library: MTMpcMimo
 * File: MTMpcMimo.typ
 * Author: B&R
 ********************************************************************
 * Data types of library MTMpcMimo
 ********************************************************************)

TYPE
	MTMpcMimoEnhancedPortType : 	STRUCT  (*Port between function block and non cyclic task class*)
		Link : REFERENCE TO MTMpcMimoEnhanced; (*Self display of function block structure*)
		StatusASync : UINT; (*Status information of non cyclic operations*)
		StatusQp : USINT; (*Status information of solution vector*)
		_statemachine : USINT; (*Internal ASYFUMA var*)
		_result : USINT; (*Internal ASYFUMA var*)
	END_STRUCT;
	MTMpcMimoEnhancedInternalType : 	STRUCT  (*Internal data of MTMpcMimoEnhanced*)
		FailureMemory : ARRAY[0..99]OF DINT; (*Failure memory of last function block errors (every item) and warnings (item per case)*)
		Warning : BOOL; (*Function block warning active*)
		Initialized : BOOL; (*First init accomplished*)
		InputError : BOOL := 0; (*0 => everything ok; 1 => imperfect/wrong fub interface allocation*)
		SolverError : INT := 0; (*Error number of solver*)
		TotalAdd : INT := 0; (*Total number of constraints added*)
		TotalDrop : INT := 0; (*Total number of constraints dropped*)
		InitStatus : BOOL := 0; (*Status == 1 => initialization*)
		SolverStatus : BOOL := 0; (*Status == 1 => solver busy*)
		PostCtrlStatus : BOOL := 0; (*Status == 1 => post control busy*)
		UpdateOld : BOOL := 0; (*Temp. mem.*)
		SystemReset : BOOL := 0; (*System behavior chronicle temp. mem.*)
		SystemResetOld : BOOL := 0; (*System behavior chronicle temp. mem.*)
		CtrlHorReduced : UDINT; (*Amount of merged control horizon blocks*)
		SlideCount : UDINT := 0; (*Internal counter to prevent control horizon overrun during shift op*)
		DRAM : UDINT; (*Displays free DRAM of the control computer*)
		CtrlTimeStamp : UDINT; (*Expired task class cycles to last control action *)
		CtrlMode : USINT; (*0 => promt contr. (no control in init); 1 promt contr. (feed forward in init); >1 => time definite contr. *)
		InitTime : UDINT; (*Time requirement of initialization procedure (ms)*)
		SolverTime : UDINT; (*Time requirement of solver (ms)*)
		PostCtrlTime : UDINT; (*Time requirement of trajectory generation (ms)*)
		ProcessTime : UDINT; (*Measured cycle time of controlled system (ms)*)
		CycleTime : LREAL; (*Measured cycle time of controlled system (ms)*)
		EigenvalueMin : LREAL; (*Min eigenvalue of hessian*)
		EigenvalueMax : LREAL; (*Max eigenvalue of hessian*)
		ActPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted sequence of controlled variables*)
		ActDeltaPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted rate of controlled variables as sequence*)
		OutDeltaOpt : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Solver access to next optimal solution*)
		StatOpt : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static optimization part*)
		UpdateActive : BOOL; (*Internal function block update in progress*)
		Scanned : MTMpcMimoEnhancedInternalScdType; (*Allows active control steps during initialization and obj. calculation*)
		StartTime : TIME; (*Internal time measurement*)
		EndTime : TIME; (*Internal time measurement*)
		OutMinDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of minimum output variables*)
		OutMaxDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of maximum output variables*)
		Bootkey : BOOL; (*First init accomplished*)
		Hzp : REFERENCE TO LREAL; (*Memory to define objective*)
		YTransform : REFERENCE TO LREAL; (*Memory to define objective*)
		Hyp : REFERENCE TO LREAL; (*Memory to define objective*)
		HypT : REFERENCE TO LREAL; (*Memory to define objective*)
		H : REFERENCE TO LREAL; (*Memory to define objective*)
		Zin : REFERENCE TO LREAL; (*Memory to define objective*)
		Rin : REFERENCE TO LREAL; (*Memory to define objective*)
		RcnIn : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoy : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoyz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hcyz : REFERENCE TO LREAL; (*Memory to define objective*)
		L : REFERENCE TO LREAL; (*Memory to define objective*)
		TM1 : REFERENCE TO LREAL; (*Temporary memory*)
		TM2 : REFERENCE TO LREAL; (*Temporary memory*)
		TM3 : REFERENCE TO LREAL; (*Temporary memory*)
		TM4 : REFERENCE TO LREAL; (*Temporary memory*)
		TM5 : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Temporary memory*)
		TM6 : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Temporary memory*)
		TMQp : ARRAY[0..18060]OF INT; (*Temporary memory*)
	END_STRUCT;
	MTMpcMimoEnhancedInternalScdType : 	STRUCT  (*Scanned data of MTMpcMimoEnhanced*)
		SystemRange : MTMpcMimoSystemRangeType; (*System range of scanned control specific data*)
		NAct : USINT; (*Number of controlled variables*)
		NOut : USINT; (*Number of manipulating variables*)
		NDist : USINT; (*Number of disturbance variables*)
		PrdHor : UDINT; (*Prediction horizon *)
		CtrlHor : UDINT; (*Control horizon *)
		OutOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to actuating variables*)
		ActOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to controlled variables*)
		OutMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Minimum value for manipulating variables*)
		OutMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Maximum value for manipulating variables*)
		SoftConstraint : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Disable enable soft constraint formulation per CV*)
		FIRModel : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Specify if system dynamic (stored as FSR/FIR <=> False/True)*)
		CtrlHorReduced : UDINT; (*Amount of merged control horizon blocks*)
		ActOld : ARRAY[0..9]OF LREAL; (*Former scanned control variable measurement*)
		Act : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned control variable measurement*)
		OutOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former scanned manipulating variable measurement*)
		OutRef : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned reference input of manipulating variables*)
		Out : ARRAY[0..9]OF LREAL; (*Scanned manipulating variables*)
		Dist : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Scanned intended sequence of disturbance values*)
		DistOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned former disturbance values*)
		DistMeasured : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned disturbance values*)
		Set : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Scanned intended sequence of reference values*)
		OptStatOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static part of optimization criteria*)
		OutDeltaOptOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former optimal solution *)
		OutDeltaScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Former scanned delta manipulating variables*)
		OutScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Manipulating variable chronicle*)
		OutStatActModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Static part of model based control variables calc. according to Out*)
		ActByOut : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Out convolution part of model based control variables calc.*)
		DistDeltaPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Specified delta disturbance variables of system*)
		DistScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Disturbance variables chronicle*)
		DistDeltaScdOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former scannced delta disturbance variables*)
		DistStatActModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Static part of model based control variables calc. according to Dist *)
		ActByDist : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Dist convolution part of model based control variables calc.*)
		ActScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Controlled variables chronicle*)
		ActDeltaModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Predicted delta control variables of next control cycle*)
		ActDeltaMeasured : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Measured delta control variables of next control cycle*)
		ActModelBased : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Model based calculated control variables*)
	END_STRUCT;
	MTMpcMimoEnhancedPerformanceType : 	STRUCT  (*Control / model quality review of MTMPCEnhanced*)
		InitTimeRatio : UINT; (*Ratio between initialization and process sample time in %*)
		CtrlTimeRatio : UINT; (*Ratio between optimization (new control action) and process sample time in %*)
		TotalTimeRatio : UINT; (*Ratio between total calculation and process sample time in %*)
		ConditionNbr : LREAL; (*Condition number of hessian according to l2 norm*)
		StatObj : LREAL; (*Stat. part of objective function*)
		DynObj : LREAL; (*Dynamic part of objective function*)
		Iter : DINT; (*Number of Iterations*)
		ActDeltaPrd : ARRAY[0..9]OF LREAL; (*Rate of model based calc. PV's*)
		ActIDeltaPrd : ARRAY[0..9]OF LREAL; (*Sum of rate of model based calc. PV's*)
		PrdError : ARRAY[0..9]OF LREAL; (*Prediction errors*)
		PrdAvgError : ARRAY[0..9]OF LREAL; (*Arithmetic mean of prediction errors*)
		PrdIAError : ARRAY[0..9]OF LREAL; (*Integral absolute errors of prediction errors*)
		CtrlError : ARRAY[0..9]OF LREAL; (*Control errors*)
		CtrlAvgError : ARRAY[0..9]OF LREAL; (*Arithmetic mean of control errors*)
		CtrlIAError : ARRAY[0..9]OF LREAL; (*Integral absolute errors of control errors*)
		OutVar : ARRAY[0..9]OF LREAL; (*Variance of manipulating variables (prediction horizon)*)
		ActVar : ARRAY[0..9]OF LREAL; (*Variance of controlled variables (prediction horizon)*)
		CorrActMeasuredPrd : ARRAY[0..9]OF LREAL; (*Correlation between PV and IdxP*)
		Slack : ARRAY[0..9]OF LREAL; (*Contain slack variables if soft constraints are enabled*)
		CycleCount : UDINT := 0; (*Internal counter till system sample time is reached (cycleFactor)*)
		PrdCompleted : BOOL := FALSE; (*Change from false to true if QP is solved and predictive data is generated => post contr finished*)
		ActIScdDeltaPrd : ARRAY[0..1999]OF LREAL; (*Cummulative sum of predicted control variable rate*)
		ActScdDeltaPrd : ARRAY[0..1999]OF LREAL; (*Predicted control variable rate*)
		PrdErrorScdOld : ARRAY[0..1999]OF LREAL; (*Prediction error FIFO memory (x_measured(k) - x_predicted(k))*)
		CtrlErrorScdOld : ARRAY[0..1999]OF LREAL; (*Control error FIFO memory*)
	END_STRUCT;
	MTMpcMimoParameterType : 	STRUCT  (*MPC parametrization structure*)
		MemMode : BOOL := FALSE; (*TRUE => allocation or rather function block operation mode / FALSE => delete memory*)
		CycleFactor : UDINT := 1; (*Adjust sampling time of controlled system (CycleFactor * task class cycle time = sample time of process)*)
		NrAct : USINT := 1; (*Number of controlled variables*)
		NrOut : USINT := 1; (*Number of manipulating variables*)
		NrDist : USINT := 1; (*Number of measured disturbances*)
		PredictionHorizon : UDINT := 100; (*Prediction horizon*)
		ControlHorizon : UDINT := 50; (*Global control horizon*)
		OutSamplesMerge : USINT := 1; (*Set up quantity of merged output trajectory entries *)
		OutOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to actuating variables*)
		ActOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to controlled variables*)
		WeightErrorExp : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Weight factor take exponential affect on control error*)
		WeightError : ARRAY[0..9]OF LREAL := [10(1.0)]; (*Weight factor take linear affect on control error*)
		OutMoveSuppression : ARRAY[0..9]OF LREAL := [10(1.0)]; (*Weight factor take linear affect on manipulating variables (0 => no alteration limit till u_min, u_max)*)
		ActDeltaWeight : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Weight openloop - closed loop delta control variables prediction amount (only IT Systems)*)
		FIRModel : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Specify system dynamic (FSR/FIR <=> False/True)*)
		SoftConstraint : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Enable soft constraint formulation per control variable*)
		OutDeltaMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Allowed minimum rate of manipulating variables*)
		OutDeltaMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Allowed maximum rate of manipulating variables*)
		OutMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Absolute minimum value for manipulating variables*)
		OutMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Absolute maximum value for manipulating variables*)
		ActSoftMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Soft lower bound constraints of control variables*)
		ActSoftMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Soft upper bound constraints of conrol variables*)
		PostCtrlDisable : BOOL; (*Disable calculation of predicted output trajectories*)
		OutRespAct0 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[0]/Out[0..9]*)
		DistRespAct0 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[0]/Dist[0..9]*)
		OutRespAct1 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[1]/Out[0..9]*)
		DistRespAct1 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[1]/Dist[0..9]*)
		OutRespAct2 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[2]/Out[0..9]*)
		DistRespAct2 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[2]/Dist[0..9]*)
		OutRespAct3 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[3]/Out[0..9]*)
		DistRespAct3 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[3]/Dist[0..9]*)
		OutRespAct4 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[4]/Out[0..9]*)
		DistRespAct4 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[4]/Dist[0..9]*)
		OutRespAct5 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[5]/Out[0..9]*)
		DistRespAct5 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[5]/Dist[0..9]*)
		OutRespAct6 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[6]/Out[0..9]*)
		DistRespAct6 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[6]/Dist[0..9]*)
		OutRespAct7 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[7]/Out[0..9]*)
		DistRespAct7 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[7]/Dist[0..9]*)
		OutRespAct8 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[8]/Out[0..9]*)
		DistRespAct8 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[8]/Dist[0..9]*)
		OutRespAct9 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[9]/Out[0..9]*)
		DistRespAct9 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[9]/Dist[0..9]*)
		SystemRange : MTMpcMimoSystemRangeType; (*System range of control specific data*)
	END_STRUCT;
	MTMpcMimoLiteInternalType : 	STRUCT  (*Internal data of MTMpcMimoLite*)
		SolverError : INT := 0; (*Error number of solver*)
		CtrlHorReduced : UDINT; (*Amount of merged control horizon blocks*)
		CycleCount : UDINT := 1; (*Internal counter till system sample time is reached*)
		InitTime : UDINT; (*Time requirement of initialization procedure (ms)*)
		SolverTime : UDINT; (*Time requirement of objective calculation procedure (ms)*)
		CycleTime : LREAL; (*Cycle time *)
		Warning : BOOL := 0; (*Temp. mem.*)
		Iter : DINT := 0; (*Number of Iterations*)
		TotalAdd : INT := 0; (*Total number of constraints added*)
		TotalDrop : INT := 0; (*Total number of constraints dropped*)
		UpdateActive : BOOL := 0; (*Temp. mem.*)
		Update : BOOL := 0; (*Temp. mem.*)
		UpdateOld : BOOL := 0; (*Temp. mem.*)
		EigenvalueMin : LREAL; (*Min eigenvalue of hessian*)
		EigenvalueMax : LREAL; (*Max eigenvalue of hessian*)
		OutMinDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of miinimum manipulating variables*)
		OutMaxDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of maximum manipulating variables*)
		ActPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted sequence of controlled variables*)
		ActDeltaPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted rate of controlled variables*)
		OutDeltaOpt : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Solver access to next optimal solution*)
		StatOpt : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static optimization part*)
		OutDeltaScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Former delta manipulating variables*)
		DistDeltaScdOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former delta disturbance variables*)
		ActScd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned controlled variables*)
		ActOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former controlled variables*)
		OutOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former manipulating variables*)
		DistOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former disturbance values*)
		Hzp : REFERENCE TO LREAL; (*Memory to define objective*)
		YTransform : REFERENCE TO LREAL; (*Memory to define objective*)
		Hyp : REFERENCE TO LREAL; (*Memory to define objective*)
		HypT : REFERENCE TO LREAL; (*Memory to define objective*)
		H : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoyz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hcyz : REFERENCE TO LREAL; (*Memory to define objective*)
		L : REFERENCE TO LREAL; (*Memory to define objective*)
		Zin : REFERENCE TO LREAL; (*Memory to define objective*)
		Rin : REFERENCE TO LREAL; (*Memory to define objective*)
		RcnIn : REFERENCE TO LREAL; (*Memory to define objective*)
		TM1 : REFERENCE TO LREAL; (*Temporary memory*)
		TM2 : REFERENCE TO LREAL; (*Temporary memory*)
		TM3 : REFERENCE TO LREAL; (*Temporary memory*)
		TM4 : REFERENCE TO LREAL; (*Temporary memory*)
		TMQp : ARRAY[0..18060]OF INT; (*Temporary memory*)
		Bootkey : UDINT; (*Internal usage*)
	END_STRUCT;
	MTMpcMimoSystemRangeType : 	STRUCT  (*MPC specific function block data range*)
		NActSum : UDINT := 0; (*Calculated objective size*)
		NOutSum : UDINT := 0; (*Calculated objective size*)
		NOutSumMerged : UDINT := 0; (*Calculated objective size*)
		NOutSumMax : UDINT := 0; (*Calculated objective size*)
		NDistSum : UDINT := 0; (*Calculated objective size*)
		NDistSumMax : UDINT := 0; (*Calculated objective size*)
		TempMemMax : UDINT := 0; (*Temporary memory size of initialization procedure*)
		QpMemMax : UDINT := 0; (*Temporary memory size of objective *)
		NSoftC : USINT := 0; (*Number of considered soft constraints*)
	END_STRUCT;
	MTMpcMimoOilFractionatorInternal : 	STRUCT 
		Ty0 : ARRAY[0..2]OF LREAL; (*Time constants MV 1 to CV's*)
		Ty1 : ARRAY[0..2]OF LREAL; (*Time constants MV 2 to CV's*)
		Ty2 : ARRAY[0..2]OF LREAL; (*Time constants MV 3 to CV's*)
		Tz0 : ARRAY[0..2]OF LREAL; (*Time constants DV 1 to CV's*)
		Tz1 : ARRAY[0..2]OF LREAL; (*Time constants DV 2 to CV's*)
		Vy0 : ARRAY[0..2]OF LREAL; (*Gain MV 1 to CV's*)
		Vy1 : ARRAY[0..2]OF LREAL; (*Gain MV 2 to CV's*)
		Vy2 : ARRAY[0..2]OF LREAL; (*Gain MV 3 to CV's*)
		Vz0 : ARRAY[0..2]OF LREAL; (*Gain DV 1 to CV's*)
		Vz1 : ARRAY[0..2]OF LREAL; (*Gain DV 2 to CV's*)
		Tty0 : ARRAY[0..2]OF UINT; (*Deadtime MV 1 to CV's*)
		Tty1 : ARRAY[0..2]OF UINT; (*Deadtime MV 2 to CV's*)
		Tty2 : ARRAY[0..2]OF UINT; (*Deadtime MV 3 to CV's*)
		Ttz0 : ARRAY[0..2]OF UINT; (*Deadtime DV 1 to CV's*)
		Ttz1 : ARRAY[0..2]OF UINT; (*Deadtime DV 2 to CV's*)
		x0Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 1 to all inputs*)
		x1Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 2 to all inputs*)
		x2Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 3 to all inputs *)
		x0Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 1 to all inputs*)
		x1Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 2 to all inputs*)
		x2Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 3 to all inputs *)
		CycleTime : LREAL; (*Cycle time of task class as well as process sample time*)
		y0Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		y1Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		y2Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		z0Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		z1Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		Bootkey : UDINT; (*Internal usage*)
	END_STRUCT;
END_TYPE
