(********************************************************************
 * COPYRIGHT -- Bernecker + Rainer
 ********************************************************************
 * Library: MTMpcMimo
 * File: MTMpcMimo.typ
 * Author: B&R
 ********************************************************************
 * Data types of library MTMpcMimo
 ********************************************************************)

TYPE
	MTMpcMimoEnhancedPortType : {REDUND_UNREPLICABLE} 	STRUCT  (*Port between function block and non cyclic task class*)
		Link : REFERENCE TO MTMpcMimoEnhanced; (*Self display of function block structure*)
		StatusASync : {REDUND_UNREPLICABLE} UINT; (*Status information of non cyclic operations*)
		StatusQp : {REDUND_UNREPLICABLE} USINT; (*Status information of solution vector*)
		_statemachine : {REDUND_UNREPLICABLE} USINT; (*Internal ASYFUMA var*)
		_result : {REDUND_UNREPLICABLE} USINT; (*Internal ASYFUMA var*)
	END_STRUCT;
	MTMpcMimoEnhancedInternalType : 	STRUCT  (*Internal data of MTMpcMimoEnhanced*)
		FailureMemory : ARRAY[0..99]OF DINT; (*Failure memory of last function block errors (every item) and warnings (item per case)*)
		Warning : {REDUND_UNREPLICABLE} BOOL; (*Function block warning active*)
		Initialized : {REDUND_UNREPLICABLE} BOOL; (*First init accomplished*)
		InputError : {REDUND_UNREPLICABLE} BOOL := 0; (*0 => everything ok; 1 => imperfect/wrong fub interface allocation*)
		SolverError : {REDUND_UNREPLICABLE} INT := 0; (*Error number of solver*)
		TotalAdd : {REDUND_UNREPLICABLE} INT := 0; (*Total number of constraints added*)
		TotalDrop : {REDUND_UNREPLICABLE} INT := 0; (*Total number of constraints dropped*)
		InitStatus : {REDUND_UNREPLICABLE} BOOL := 0; (*Status == 1 => initialization*)
		SolverStatus : {REDUND_UNREPLICABLE} BOOL := 0; (*Status == 1 => solver busy*)
		PostCtrlStatus : {REDUND_UNREPLICABLE} BOOL := 0; (*Status == 1 => post control busy*)
		UpdateOld : {REDUND_UNREPLICABLE} BOOL := 0; (*Temp. mem.*)
		SystemReset : {REDUND_UNREPLICABLE} BOOL := 0; (*System behavior chronicle temp. mem.*)
		SystemResetOld : {REDUND_UNREPLICABLE} BOOL := 0; (*System behavior chronicle temp. mem.*)
		CtrlHorReduced : {REDUND_UNREPLICABLE} UDINT; (*Amount of merged control horizon blocks*)
		SlideCount : {REDUND_UNREPLICABLE} UDINT := 0; (*Internal counter to prevent control horizon overrun during shift op*)
		DRAM : {REDUND_UNREPLICABLE} UDINT; (*Displays free DRAM of the control computer*)
		CtrlTimeStamp : UDINT; (*Expired task class cycles to last control action *)
		CtrlMode : USINT; (*0 => promt contr. (no control in init); 1 promt contr. (feed forward in init); >1 => time definite contr. *)
		InitTime : {REDUND_UNREPLICABLE} UDINT; (*Time requirement of initialization procedure (ms)*)
		SolverTime : {REDUND_UNREPLICABLE} UDINT; (*Time requirement of solver (ms)*)
		PostCtrlTime : {REDUND_UNREPLICABLE} UDINT; (*Time requirement of trajectory generation (ms)*)
		ProcessTime : {REDUND_UNREPLICABLE} UDINT; (*Measured cycle time of controlled system (ms)*)
		CycleTime : {REDUND_UNREPLICABLE} LREAL; (*Measured cycle time of controlled system (ms)*)
		EigenvalueMin : {REDUND_UNREPLICABLE} LREAL; (*Min eigenvalue of hessian*)
		EigenvalueMax : {REDUND_UNREPLICABLE} LREAL; (*Max eigenvalue of hessian*)
		ActPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted sequence of controlled variables*)
		ActDeltaPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted rate of controlled variables as sequence*)
		OutDeltaOpt : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Solver access to next optimal solution*)
		StatOpt : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static optimization part*)
		UpdateActive : BOOL; (*Internal function block update in progress*)
		Scanned : MTMpcMimoEnhancedInternalScdType; (*Allows active control steps during initialization and obj. calculation*)
		StartTime : {REDUND_UNREPLICABLE} TIME; (*Internal time measurement*)
		EndTime : {REDUND_UNREPLICABLE} TIME; (*Internal time measurement*)
		OutMinDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of minimum output variables*)
		OutMaxDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of maximum output variables*)
		Bootkey : {REDUND_UNREPLICABLE} BOOL; (*First init accomplished*)
		Hzp : REFERENCE TO LREAL; (*Memory to define objective*)
		YTransform : REFERENCE TO LREAL; (*Memory to define objective*)
		Hyp : REFERENCE TO LREAL; (*Memory to define objective*)
		HypT : REFERENCE TO LREAL; (*Memory to define objective*)
		H : REFERENCE TO LREAL; (*Memory to define objective*)
		Zin : REFERENCE TO LREAL; (*Memory to define objective*)
		Rin : REFERENCE TO LREAL; (*Memory to define objective*)
		RcnIn : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoy : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoyz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hcyz : REFERENCE TO LREAL; (*Memory to define objective*)
		L : REFERENCE TO LREAL; (*Memory to define objective*)
		TM1 : REFERENCE TO LREAL; (*Temporary memory*)
		TM2 : REFERENCE TO LREAL; (*Temporary memory*)
		TM3 : REFERENCE TO LREAL; (*Temporary memory*)
		TM4 : REFERENCE TO LREAL; (*Temporary memory*)
		TM5 : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Temporary memory*)
		TM6 : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Temporary memory*)
		TMQp : {REDUND_UNREPLICABLE} ARRAY[0..18060]OF INT; (*Temporary memory*)
	END_STRUCT;
	MTMpcMimoEnhancedInternalScdType : 	STRUCT  (*Scanned data of MTMpcMimoEnhanced*)
		SystemRange : {REDUND_UNREPLICABLE} MTMpcMimoSystemRangeType; (*System range of scanned control specific data*)
		NAct : {REDUND_UNREPLICABLE} USINT; (*Number of controlled variables*)
		NOut : {REDUND_UNREPLICABLE} USINT; (*Number of manipulating variables*)
		NDist : {REDUND_UNREPLICABLE} USINT; (*Number of disturbance variables*)
		PrdHor : {REDUND_UNREPLICABLE} UDINT; (*Prediction horizon *)
		CtrlHor : {REDUND_UNREPLICABLE} UDINT; (*Control horizon *)
		OutOperatingPoint : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to actuating variables*)
		ActOperatingPoint : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to controlled variables*)
		OutMin : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL := [10(0.0)]; (*Minimum value for manipulating variables*)
		OutMax : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL := [10(0.0)]; (*Maximum value for manipulating variables*)
		SoftConstraint : {REDUND_UNREPLICABLE} ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Disable enable soft constraint formulation per CV*)
		FIRModel : {REDUND_UNREPLICABLE} ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Specify if system dynamic (stored as FSR/FIR <=> False/True)*)
		CtrlHorReduced : {REDUND_UNREPLICABLE} UDINT; (*Amount of merged control horizon blocks*)
		ActOld : ARRAY[0..9]OF LREAL; (*Former scanned control variable measurement*)
		Act : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned control variable measurement*)
		OutOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former scanned manipulating variable measurement*)
		OutRef : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned reference input of manipulating variables*)
		Out : ARRAY[0..9]OF LREAL; (*Scanned manipulating variables*)
		Dist : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Scanned intended sequence of disturbance values*)
		DistOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned former disturbance values*)
		DistMeasured : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned disturbance values*)
		Set : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Scanned intended sequence of reference values*)
		OptStatOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static part of optimization criteria*)
		OutDeltaOptOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former optimal solution *)
		OutDeltaScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Former scanned delta manipulating variables*)
		OutScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Manipulating variable chronicle*)
		OutStatActModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Static part of model based control variables calc. according to Out*)
		ActByOut : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Out convolution part of model based control variables calc.*)
		DistDeltaPrd : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Specified delta disturbance variables of system*)
		DistScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Disturbance variables chronicle*)
		DistDeltaScdOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former scannced delta disturbance variables*)
		DistStatActModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Static part of model based control variables calc. according to Dist *)
		ActByDist : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Dist convolution part of model based control variables calc.*)
		ActScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Controlled variables chronicle*)
		ActDeltaModel : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Predicted delta control variables of next control cycle*)
		ActDeltaMeasured : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Measured delta control variables of next control cycle*)
		ActModelBased : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Model based calculated control variables*)
	END_STRUCT;
	MTMpcMimoEnhancedPerformanceType : 	STRUCT  (*Control / model quality review of MTMPCEnhanced*)
		InitTimeRatio : {REDUND_UNREPLICABLE} UINT; (*Ratio between initialization and process sample time in %*)
		CtrlTimeRatio : {REDUND_UNREPLICABLE} UINT; (*Ratio between optimization (new control action) and process sample time in %*)
		TotalTimeRatio : {REDUND_UNREPLICABLE} UINT; (*Ratio between total calculation and process sample time in %*)
		ConditionNbr : {REDUND_UNREPLICABLE} LREAL; (*Condition number of hessian according to l2 norm*)
		StatObj : {REDUND_UNREPLICABLE} LREAL; (*Stat. part of objective function*)
		DynObj : {REDUND_UNREPLICABLE} LREAL; (*Dynamic part of objective function*)
		Iter : {REDUND_UNREPLICABLE} DINT; (*Number of Iterations*)
		ActDeltaPrd : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Rate of model based calc. PV's*)
		ActIDeltaPrd : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Sum of rate of model based calc. PV's*)
		PrdError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Prediction errors*)
		PrdAvgError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Arithmetic mean of prediction errors*)
		PrdIAError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Integral absolute errors of prediction errors*)
		CtrlError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Control errors*)
		CtrlAvgError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Arithmetic mean of control errors*)
		CtrlIAError : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Integral absolute errors of control errors*)
		OutVar : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Variance of manipulating variables (prediction horizon)*)
		ActVar : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Variance of controlled variables (prediction horizon)*)
		CorrActMeasuredPrd : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Correlation between PV and IdxP*)
		Slack : {REDUND_UNREPLICABLE} ARRAY[0..9]OF LREAL; (*Contain slack variables if soft constraints are enabled*)
		CycleCount : UDINT := 0; (*Internal counter till system sample time is reached (cycleFactor)*)
		PrdCompleted : {REDUND_UNREPLICABLE} BOOL := FALSE; (*Change from false to true if QP is solved and predictive data is generated => post contr finished*)
		ActIScdDeltaPrd : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL; (*Cummulative sum of predicted control variable rate*)
		ActScdDeltaPrd : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL; (*Predicted control variable rate*)
		PrdErrorScdOld : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL; (*Prediction error FIFO memory (x_measured(k) - x_predicted(k))*)
		CtrlErrorScdOld : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL; (*Control error FIFO memory*)
	END_STRUCT;
	MTMpcMimoParameterType : 	STRUCT  (*MPC parametrization structure*)
		MemMode : BOOL := FALSE; (*TRUE => allocation or rather function block operation mode / FALSE => delete memory*)
		CycleFactor : UDINT := 1; (*Adjust sampling time of controlled system (CycleFactor * task class cycle time = sample time of process)*)
		NrAct : USINT := 1; (*Number of controlled variables*)
		NrOut : USINT := 1; (*Number of manipulating variables*)
		NrDist : USINT := 1; (*Number of measured disturbances*)
		PredictionHorizon : UDINT := 100; (*Prediction horizon*)
		ControlHorizon : UDINT := 50; (*Global control horizon*)
		OutSamplesMerge : USINT := 1; (*Set up quantity of merged output trajectory entries *)
		OutOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to actuating variables*)
		ActOperatingPoint : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Adjust static operating points regarded to controlled variables*)
		WeightErrorExp : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Weight factor take exponential affect on control error*)
		WeightError : ARRAY[0..9]OF LREAL := [10(1.0)]; (*Weight factor take linear affect on control error*)
		OutMoveSuppression : ARRAY[0..9]OF LREAL := [10(1.0)]; (*Weight factor take linear affect on manipulating variables (0 => no alteration limit till u_min, u_max)*)
		ActDeltaWeight : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Weight openloop - closed loop delta control variables prediction amount (only IT Systems)*)
		FIRModel : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Specify system dynamic (FSR/FIR <=> False/True)*)
		SoftConstraint : ARRAY[0..9]OF BOOL := [10(FALSE)]; (*Enable soft constraint formulation per control variable*)
		OutDeltaMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Allowed minimum rate of manipulating variables*)
		OutDeltaMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Allowed maximum rate of manipulating variables*)
		OutMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Absolute minimum value for manipulating variables*)
		OutMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Absolute maximum value for manipulating variables*)
		ActSoftMin : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Soft lower bound constraints of control variables*)
		ActSoftMax : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Soft upper bound constraints of conrol variables*)
		PostCtrlDisable : BOOL; (*Disable calculation of predicted output trajectories*)
		OutRespAct0 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[0]/Out[0..9]*)
		DistRespAct0 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[0]/Dist[0..9]*)
		OutRespAct1 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[1]/Out[0..9]*)
		DistRespAct1 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[1]/Dist[0..9]*)
		OutRespAct2 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[2]/Out[0..9]*)
		DistRespAct2 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[2]/Dist[0..9]*)
		OutRespAct3 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[3]/Out[0..9]*)
		DistRespAct3 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[3]/Dist[0..9]*)
		OutRespAct4 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[4]/Out[0..9]*)
		DistRespAct4 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[4]/Dist[0..9]*)
		OutRespAct5 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[5]/Out[0..9]*)
		DistRespAct5 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[5]/Dist[0..9]*)
		OutRespAct6 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[6]/Out[0..9]*)
		DistRespAct6 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[6]/Dist[0..9]*)
		OutRespAct7 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[7]/Out[0..9]*)
		DistRespAct7 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[7]/Dist[0..9]*)
		OutRespAct8 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[8]/Out[0..9]*)
		DistRespAct8 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[8]/Dist[0..9]*)
		OutRespAct9 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[9]/Out[0..9]*)
		DistRespAct9 : REFERENCE TO LREAL; (*FSR/FIR characterize Act[9]/Dist[0..9]*)
		SystemRange : {REDUND_UNREPLICABLE} MTMpcMimoSystemRangeType; (*System range of control specific data*)
	END_STRUCT;
	MTMpcMimoLiteInternalType : 	STRUCT  (*Internal data of MTMpcMimoLite*)
		SolverError : {REDUND_UNREPLICABLE} INT := 0; (*Error number of solver*)
		CtrlHorReduced : {REDUND_UNREPLICABLE} UDINT; (*Amount of merged control horizon blocks*)
		CycleCount : UDINT := 1; (*Internal counter till system sample time is reached*)
		InitTime : {REDUND_UNREPLICABLE} UDINT; (*Time requirement of initialization procedure (ms)*)
		SolverTime : {REDUND_UNREPLICABLE} UDINT; (*Time requirement of objective calculation procedure (ms)*)
		CycleTime : LREAL; (*Cycle time *)
		Warning : {REDUND_UNREPLICABLE} BOOL := 0; (*Temp. mem.*)
		Iter : {REDUND_UNREPLICABLE} DINT := 0; (*Number of Iterations*)
		TotalAdd : {REDUND_UNREPLICABLE} INT := 0; (*Total number of constraints added*)
		TotalDrop : {REDUND_UNREPLICABLE} INT := 0; (*Total number of constraints dropped*)
		UpdateActive : {REDUND_UNREPLICABLE} BOOL := 0; (*Temp. mem.*)
		Update : {REDUND_UNREPLICABLE} BOOL := 0; (*Temp. mem.*)
		UpdateOld : {REDUND_UNREPLICABLE} BOOL := 0; (*Temp. mem.*)
		EigenvalueMin : {REDUND_UNREPLICABLE} LREAL; (*Min eigenvalue of hessian*)
		EigenvalueMax : {REDUND_UNREPLICABLE} LREAL; (*Max eigenvalue of hessian*)
		OutMinDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of miinimum manipulating variables*)
		OutMaxDragInd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Drag indicator of maximum manipulating variables*)
		ActPrd : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted sequence of controlled variables*)
		ActDeltaPrd : {REDUND_UNREPLICABLE} ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Predicted rate of controlled variables*)
		OutDeltaOpt : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Solver access to next optimal solution*)
		StatOpt : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Static optimization part*)
		OutDeltaScdOld : ARRAY[0..1999]OF LREAL := [2000(0.0)]; (*Former delta manipulating variables*)
		DistDeltaScdOld : ARRAY[0..2009]OF LREAL := [2010(0.0)]; (*Former delta disturbance variables*)
		ActScd : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Scanned controlled variables*)
		ActOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former controlled variables*)
		OutOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former manipulating variables*)
		DistOld : ARRAY[0..9]OF LREAL := [10(0.0)]; (*Former disturbance values*)
		Hzp : REFERENCE TO LREAL; (*Memory to define objective*)
		YTransform : REFERENCE TO LREAL; (*Memory to define objective*)
		Hyp : REFERENCE TO LREAL; (*Memory to define objective*)
		HypT : REFERENCE TO LREAL; (*Memory to define objective*)
		H : REFERENCE TO LREAL; (*Memory to define objective*)
		Hoyz : REFERENCE TO LREAL; (*Memory to define objective*)
		Hcyz : REFERENCE TO LREAL; (*Memory to define objective*)
		L : REFERENCE TO LREAL; (*Memory to define objective*)
		Zin : REFERENCE TO LREAL; (*Memory to define objective*)
		Rin : REFERENCE TO LREAL; (*Memory to define objective*)
		RcnIn : REFERENCE TO LREAL; (*Memory to define objective*)
		TM1 : REFERENCE TO LREAL; (*Temporary memory*)
		TM2 : REFERENCE TO LREAL; (*Temporary memory*)
		TM3 : REFERENCE TO LREAL; (*Temporary memory*)
		TM4 : REFERENCE TO LREAL; (*Temporary memory*)
		TMQp : {REDUND_UNREPLICABLE} ARRAY[0..18060]OF INT; (*Temporary memory*)
		Bootkey : {REDUND_UNREPLICABLE} UDINT; (*Internal usage*)
	END_STRUCT;
	MTMpcMimoSystemRangeType : {REDUND_UNREPLICABLE} 	STRUCT  (*MPC specific function block data range*)
		NActSum : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		NOutSum : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		NOutSumMerged : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		NOutSumMax : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		NDistSum : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		NDistSumMax : {REDUND_UNREPLICABLE} UDINT := 0; (*Calculated objective size*)
		TempMemMax : {REDUND_UNREPLICABLE} UDINT := 0; (*Temporary memory size of initialization procedure*)
		QpMemMax : {REDUND_UNREPLICABLE} UDINT := 0; (*Temporary memory size of objective *)
		NSoftC : {REDUND_UNREPLICABLE} USINT := 0; (*Number of considered soft constraints*)
	END_STRUCT;
	MTMpcMimoOilFractionatorInternal : 	STRUCT 
		Ty0 : ARRAY[0..2]OF LREAL; (*Time constants MV 1 to CV's*)
		Ty1 : ARRAY[0..2]OF LREAL; (*Time constants MV 2 to CV's*)
		Ty2 : ARRAY[0..2]OF LREAL; (*Time constants MV 3 to CV's*)
		Tz0 : ARRAY[0..2]OF LREAL; (*Time constants DV 1 to CV's*)
		Tz1 : ARRAY[0..2]OF LREAL; (*Time constants DV 2 to CV's*)
		Vy0 : ARRAY[0..2]OF LREAL; (*Gain MV 1 to CV's*)
		Vy1 : ARRAY[0..2]OF LREAL; (*Gain MV 2 to CV's*)
		Vy2 : ARRAY[0..2]OF LREAL; (*Gain MV 3 to CV's*)
		Vz0 : ARRAY[0..2]OF LREAL; (*Gain DV 1 to CV's*)
		Vz1 : ARRAY[0..2]OF LREAL; (*Gain DV 2 to CV's*)
		Tty0 : ARRAY[0..2]OF UINT; (*Deadtime MV 1 to CV's*)
		Tty1 : ARRAY[0..2]OF UINT; (*Deadtime MV 2 to CV's*)
		Tty2 : ARRAY[0..2]OF UINT; (*Deadtime MV 3 to CV's*)
		Ttz0 : ARRAY[0..2]OF UINT; (*Deadtime DV 1 to CV's*)
		Ttz1 : ARRAY[0..2]OF UINT; (*Deadtime DV 2 to CV's*)
		x0Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 1 to all inputs*)
		x1Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 2 to all inputs*)
		x2Internal : ARRAY[0..4]OF LREAL; (*Systembehavior CV 3 to all inputs *)
		x0Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 1 to all inputs*)
		x1Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 2 to all inputs*)
		x2Old : ARRAY[0..4]OF LREAL; (*Systembehavior CV 3 to all inputs *)
		CycleTime : {REDUND_UNREPLICABLE} LREAL; (*Cycle time of task class as well as process sample time*)
		y0Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		y1Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		y2Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		z0Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		z1Buffer : ARRAY[0..199]OF LREAL; (*Internal usage*)
		Bootkey : {REDUND_UNREPLICABLE} UDINT; (*Internal usage*)
	END_STRUCT;
END_TYPE
